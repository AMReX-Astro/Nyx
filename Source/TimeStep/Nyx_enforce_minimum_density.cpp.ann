#include <Nyx.H>
#include <Nyx_enforce_minimum_density.H>
#include <constants_cosmo.H>

using namespace amrex;

void
Nyx::enforce_minimum_density( MultiFab& S_old, MultiFab& S_new, MultiFab& reset_e_src,
                              Real dt, Real a_old, Real a_new)
{
    BL_PROFILE("Nyx::enforce_minimum_density()");

    if (verbose)
      amrex::Print() << "Enforce minimum density... " << std::endl;

    MultiFab::RegionTag amrhydro_tag("HydroUpdate_" + std::to_string(level));

    if (S_new.min(Density_comp) < small_dens)
    {
        if (enforce_min_density_type == "floor")
        {
            enforce_minimum_density_floor(S_new, dt, a_old, a_new);

        } else if (enforce_min_density_type == "conservative") {
            enforce_minimum_density_cons(S_old, S_new, reset_e_src, dt, a_old, a_new);

        } else {
            amrex::Abort("Don't know this enforce_min_density_type");
        }
    }
}

void
Nyx::enforce_minimum_density_floor( MultiFab& S_new,
                                    Real dt, Real a_old, Real a_new )
{
    int lnum_spec    = NumSpec;
    Real lsmall_dens = small_dens;
    Real lgamma_minus_1 = gamma - 1.0;
    Real lsmall_temp = small_temp;
    auto atomic_rates = atomic_rates_glob;

    //
    //  Reset negative density to small_dens, set (rho e) and (rho E) from small_temp  and zero out momenta
    //
#ifdef _OPENMP
#pragma omp parallel if (Gpu::notInLaunchRegion())
#endif
    for (MFIter mfi(S_new,TilingIfNotGPU()); mfi.isValid(); ++mfi)
    {
        // Only update on valid cells
        const amrex::Box& bx = mfi.tilebox();
        auto const& uout = S_new.array(mfi);

         amrex::ParallelFor(bx, [=] AMREX_GPU_DEVICE(int i, int j, int k) noexcept
         {
             floor_density(i, j, k, uout, atomic_rates, lnum_spec, a_new, lgamma_minus_1, lsmall_dens, lsmall_temp);
         });
    }
}

void
Nyx::enforce_minimum_density_cons ( MultiFab& S_old, MultiFab& S_new, MultiFab& reset_e_src,
                                    Real dt, Real a_old, Real a_new )
{
    bool debug = false;

    int lnum_spec    = NumSpec;
#ifndef CONST_SPECIES
    int lfirst_spec  = FirstSpec_comp;
#endif
    Real lsmall_dens = small_dens;
  
    Real cur_time = state[State_Type].curTime();

    // Define MultiFabs to hold the fluxes so we can add these to flux registers
    amrex::MultiFab hydro_fluxes[AMREX_SPACEDIM];
    int finest_level = parent->finestLevel();

    //
    // Get pointers to Flux registers, or set pointer to zero if not there.
    //
    amrex::FluxRegister* fine    = 0;
    amrex::FluxRegister* current = 0;

    if(finest_level!=0)
    {
        for (int j = 0; j < AMREX_SPACEDIM; j++)
        {
            hydro_fluxes[j].define(getEdgeBoxArray(j), dmap, NUM_STATE, 0);
            hydro_fluxes[j].setVal(0.0);
        }
        if (do_reflux)
        {
            if (level < finest_level)
            {
                fine = &get_flux_reg(level+1);
            }
            if (level > 0) {
                current = &get_flux_reg(level);
            }
        }
    }

    if (S_new.contains_nan())
       amrex::Abort("NaN in enforce_minimum_density before we start iterations");

    // We need to define this temporary because S_new only has one ghost cell and we need two.
    MultiFab Sborder;
    Sborder.define(grids, S_new.DistributionMap(), S_new.nComp(), 2);

    // Define face-based coefficients to be defined when enforcing minimum density 
    //     then used to enjoy the updates of all the other variables
    // The ghost face space is only needed as temp space; we only use "valid" faces...
    MultiFab mu_x(amrex::convert(grids,IntVect(1,0,0)), dmap, 1, 1);
    MultiFab mu_y(amrex::convert(grids,IntVect(0,1,0)), dmap, 1, 1);
    MultiFab mu_z(amrex::convert(grids,IntVect(0,0,1)), dmap, 1, 1);

    Real old_min_before[6]; 
    Real new_min_before[6]; 
    Real new_min_after[6]; 
    Real rho_old_sum_before, rho_new_sum_before;

    if (debug) 
    {
        old_min_before[0] = S_old.min(Density_comp);
        old_min_before[1] = S_old.min(Xmom_comp);
        old_min_before[2] = S_old.min(Ymom_comp);
        old_min_before[3] = S_old.min(Zmom_comp);
        old_min_before[4] = S_old.min(Eden_comp);
        old_min_before[5] = S_old.min(Eint_comp);

        new_min_before[0] = S_new.min(Density_comp);
        new_min_before[1] = S_new.min(Xmom_comp);
        new_min_before[2] = S_new.min(Ymom_comp);
        new_min_before[3] = S_new.min(Zmom_comp);
        new_min_before[4] = S_new.min(Eden_comp);
        new_min_before[5] = S_new.min(Eint_comp);

        rho_old_sum_before = S_old.sum(Density_comp);
        rho_new_sum_before = S_new.sum(Density_comp);
     }

     Real rho_new_sum_after;

     Real rho_new_min = new_min_before[0];

     bool too_low = (rho_new_min < small_dens);

     int iter = 0;

     // 10 is an arbitrary limit here -- just to make sure we don't get stuck here somehow 
     while (too_low and iter < 10)
     {
        // First make sure that all ghost cells are updated because we use them in defining fluxes
        // Note that below we update S_new, not Sborder, so we must FillPatch each time.
        FillPatch(*this, Sborder, 2, cur_time, State_Type, Density_comp, Sborder.nComp());

        // Initialize to zero; these will only be non-zero at a face across which density is passed...
        mu_x.setVal(0.);
        mu_y.setVal(0.);
        mu_z.setVal(0.);

        // This will hold the update to each cell due to enforcing minimum density in a conservative way
        MultiFab update(grids , dmap, Sborder.nComp(), 0);
        update.setVal(0.);

#ifdef _OPENMP
#pragma omp parallel if (Gpu::notInLaunchRegion())
#endif
        for (MFIter mfi(Sborder,TilingIfNotGPU()); mfi.isValid(); ++mfi)
        {
            const amrex::Box& gbx = mfi.growntilebox(1);
            auto const& sbord = Sborder.array(mfi);
            auto const& mu_x_arr = mu_x.array(mfi);
            auto const& mu_y_arr = mu_y.array(mfi);
            auto const& mu_z_arr = mu_z.array(mfi);

            amrex::ParallelFor(gbx, [=] AMREX_GPU_DEVICE(int i, int j, int k) noexcept
            {
              compute_mu_for_enforce_min(i, j, k, Density_comp, sbord, mu_x_arr, mu_y_arr, mu_z_arr, lsmall_dens);
            });
        }

#ifdef _OPENMP
#pragma omp parallel if (Gpu::notInLaunchRegion())
#endif
        for (MFIter mfi(Sborder,TilingIfNotGPU()); mfi.isValid(); ++mfi)
        {
            // Only update on valid cells
            const amrex::Box& bx = mfi.tilebox();
            auto const& sbord_arr = Sborder.array(mfi);
            auto const& mu_x_arr  = mu_x.array(mfi);
            auto const& mu_y_arr  = mu_y.array(mfi);
            auto const& mu_z_arr  = mu_z.array(mfi);
            auto const& upd_arr   = update.array(mfi);

            amrex::ParallelFor(bx, [=] AMREX_GPU_DEVICE(int i, int j, int k) noexcept
            {
              create_update_for_minimum(i, j, k, Density_comp, sbord_arr, 
                                        mu_x_arr, mu_y_arr, mu_z_arr, upd_arr
#ifndef CONST_SPECIES
                                       ,lfirst_spec, lnum_spec
#endif
                                                              );
            });
        }

        S_new.plus(update,0,S_new.nComp(),0);

#ifdef SDC
        MultiFab::Copy(reset_e_src,update,Eint_comp,0,1,0);
#endif

        if (S_new.contains_nan())
        {
           amrex::Print() << "Doing iteration iter " << std::endl; 
           amrex::Abort("   and finding NaN in enforce_minimum_density");
        }

        // This is used to decide whether to continue the iteration
        new_min_after[0] = S_new.min(Density_comp);

        if (debug) 
        {
             new_min_after[1] = S_new.min(Xmom_comp);
             new_min_after[2] = S_new.min(Ymom_comp);
             new_min_after[3] = S_new.min(Zmom_comp);
             new_min_after[4] = S_new.min(Eden_comp);
             new_min_after[5] = S_new.min(Eint_comp);

            amrex::Print() << "After " << iter+1 << " iterations " << std::endl;
            amrex::Print() << "  MIN OF rho: old / new / new new " << 
                old_min_before[0] << " " << new_min_before[0] << " " << new_min_after[0] << std::endl;
            amrex::Print() << "  MIN OF  ru: old / new / new new " << 
                old_min_before[1] << " " << new_min_before[1] << " " << new_min_after[1] << std::endl;
            amrex::Print() << "  MIN OF  rv: old / new / new new " << 
                old_min_before[2] << " " << new_min_before[2] << " " << new_min_after[2] << std::endl;
            amrex::Print() << "  MIN OF  rw: old / new / new new " << 
                old_min_before[3] << " " << new_min_before[3] << " " << new_min_after[3] << std::endl;
            amrex::Print() << "  MIN OF  rE: old / new / new new " << 
                old_min_before[4] << " " << new_min_before[4] << " " << new_min_after[4] << std::endl;
            amrex::Print() << "  MIN OF  re: old / new / new new " << 
                old_min_before[5] << " " << new_min_before[5] << " " << new_min_after[5] << std::endl;
        }

        too_low = (new_min_after[0] < small_dens);
        iter++;

    } // iter

    rho_new_sum_after = S_new.sum(Density_comp);

    amrex::Print() << "After " << iter << " iterations " << std::endl;
    amrex::Print() << "  SUM OF rho_old / rho_new / new rho_new " << 
            rho_old_sum_before << " " << rho_new_sum_before << " " << rho_new_sum_after << std::endl;

    if (new_min_after[0] < small_dens)
       amrex::Abort("Not able to enforce small_dens this way after all");
}
